on:
  workflow_dispatch:
  workflow_call:
    inputs:
      r-version:
        description: 'The version of R to use'
        default: '4.1'
        required: false
        type: string
  push:
    branches:
      - main
      - devel
      - pre-release
  pull_request:
    branches:
      - main
      - devel
      - pre-release

env:
  # branch name for PR
  pr:
    source-branch: update_templates_data
    repo: pharmaverse/pharmaverseadam
    target-branch: main
  # data folder name for templates
  templates_data_folder: ./data/
  # repositories variables for PRs
  admiralonco:
    reviewers: ["bundfussr", "cicdguy", "manciniedoardo"]
  admiraldev:
    reviewers: ["bms63", "cicdguy", "manciniedoardo"]
  admiraltemplate:
    reviewers: ["bms63", "cicdguy,bundfussr", "manciniedoardo"]
  admiralophtha:
    reviewers: ["cicdguy", "manciniedoardo"]
  admiral:
    reviewers: ["dgrassellyb", "cicdguy"]
  admiral.test:
    reviewers: ["bms63", "bundfussr", "manciniedoardo"]
  admiralvaccine:
    reviewers: ["bms63", "manciniedoardo"]

name: Check Templates

concurrency:
  group: templates-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  get_r_version:
    name: Get R version
    runs-on: ubuntu-latest
    if: >
      !contains(github.event.commits[0].message, '[skip check_templates]')
    outputs:
      r-version: ${{ steps.normalizer.outputs.R_VERSION }}
    steps:
      - name: Normalize inputs
        id: normalizer
        run: |
          R_VERSION="${{ inputs.r-version }}"
          if [ "$R_VERSION" == "" ]
          then {
            R_VERSION="4.1"
          }
          fi
          echo "R_VERSION=$R_VERSION" >> $GITHUB_OUTPUT
        shell: bash

  check_templates:
    name: Verify
    if: >
      !contains(github.event.commits[0].message, '[skip check_templates]')
    runs-on: ubuntu-latest
    container:
      image: "ghcr.io/pharmaverse/admiralci-${{needs.get_r_version.outputs.r-version}}:latest"
    needs: get_r_version

    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
    steps:
      ##################### BEGIN boilerplate steps #####################
      - name: Get branch names
        id: branch-name
        uses: tj-actions/branch-names@v5.4

      - name: Checkout repo (PR) ðŸ›Ž
        uses: actions/checkout@v3
        if: github.event_name == 'pull_request'
        with:
          ref: ${{ steps.branch-name.outputs.head_ref_branch }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}

      - name: Checkout repository
        uses: actions/checkout@v3
        if: github.event_name != 'pull_request'
        with:
          ref: ${{ steps.branch-name.outputs.head_ref_branch }}
          fetch-depth: 0

      - name: Add safe directory
        run: |
          git config --global --add safe.directory "${GITHUB_WORKSPACE}" # open issue: git dubious ownership running in docker container context: https://github.com/actions/runner/issues/2033
        shell: bash

      - name: Normalize inputs
        id: normalizer
        run: |
          function remove_substring() {
              echo "${1//$2}"
          }
          BRANCH=${{ steps.branch-name.outputs.head_ref_branch }}
          if [ "${BRANCH}" == "" ]
          then {
            BRANCH=$(git name-rev HEAD | awk '{print $NF}')
          }
          fi
          if [[ $BRANCH == remotes/pull/* ]]
          then {
            PR=$(remove_substring "$BRANCH" "/merge")
            PR=$(remove_substring "$PR" "remotes/")
            PR=$(echo $PR | sed 's/pull/pulls/')
            echo "Accessing repos/${GITHUB_REPOSITORY}/${PR}"
            BRANCH=$(gh api -X GET repos/${GITHUB_REPOSITORY}/${PR} | jq -r '.head.ref')
          }
          fi
          echo "BRANCH is $BRANCH"
          R_VERSION="${{ inputs.r-version }}"
          if [ "$R_VERSION" == "" ]
          then {
            R_VERSION="4.1"
          }
          fi
          echo "R_VERSION=$R_VERSION" >> $GITHUB_OUTPUT
          echo "SD_GIT_REF=$BRANCH" >> $GITHUB_OUTPUT
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.staged.dependencies
          key: staged-deps
          restore-keys: staged-deps

      - name: Run Staged dependencies
        uses: insightsengineering/staged-dependencies-action@v1
        with:
          run-system-dependencies: false
          enable-check: false
          git-ref: ${{ steps.normalizer.outputs.SD_GIT_REF }}
          renv-restore: false
        env:
          GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
      ##################### END boilerplate steps #####################

      - name: Install package
        run: |
          R CMD build --no-build-vignettes --no-manual .
          R CMD INSTALL *.tar.gz

      - name: Run Template Scripts
        run: |
          desc <- read.dcf("DESCRIPTION")
          package_name <- as.character(desc[, "Package"])
          templates <- list.files(
            system.file("templates", package = package_name),
            pattern = "\\.R$",
            ignore.case = TRUE,
            full.names = TRUE
          )
          if (length(templates) > 0) {
            exit_codes <- purrr::map_chr(templates, function(file) {
              cmd <- sprintf("Rscript --vanilla %s", file)
              system(cmd)
            })
            if (any(exit_codes == 1L)) {
              failed_scripts <- basename(templates)[which(exit_codes == 1L)]
              err_msg <- sprintf(
                "Executing the following template scripts failed:\n%s",
                paste("-", failed_scripts, collapse = "\n")
              )
              stop(err_msg, call. = FALSE)
            }
          }
        shell: Rscript {0} # TODO: add other formats than RDS

      # store templates data as artifacts
      - name: Archive production artifacts
        uses: actions/upload-artifact@v3
        with:
          name: data_templates
          path: |
            ./inst/templates/tmp

      - name: Checkout repo (PR) ðŸ›Ž
        uses: actions/checkout@v3
        with:
          ref: main
          repository: ${{ env.pr.repo }}

      - name: Download a single artifact
        uses: actions/download-artifact@v3
        id: download
        with:
          name: data_templates

      # detect diffs om templates data
      - name: Check templates changes
        id: changes
        run: |
          mkdir -p "${{ env.templates_data_folder }}"
          cp -r "${{steps.download.outputs.download-path}}/." "${{ env.templates_data_folder }}"
          diffs=$(git diff "${{ env.templates_data_folder }}")
          echo "diff=$diff" >> $GITHUB_OUTPUT
          if [ -z "$diffs" ]; then echo "No changes detected after running templates. Stop here"; else echo "Changes detected, new PR will be created"; fi

      # if diff detected, push changes
      - name: Commit and push changes in {{ env.pr.repo }}
        if: ${{ steps.changes.outputs.diff != '' }}
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: templates data updates from ${{ github.repository }}
          file_pattern: 'data/*'
          repository: "{{ env.pr.repo }}"
          commit_user_name: pharmaverse-bot
          commit_user_email: 113703390+pharmaverse-bot@users.noreply.github.com
          branch: "{{ env.pr.source-branch }}"
          create_branch: true

      - name: Create Pull Request
        if: ${{ steps.changes.outputs.diff != '' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PHARMAVERSE_BOT }}
          script: |
            // Look for any open PRs
            const repo_owner = "${{ github.repository_owner }}";
            const repo_name = "${{ env.pr.repo }}";
            const result = await github.rest.pulls.list({
              owner: repo_owner,
              repo: repo_name,
              state: "open"
            })
            let create_new_pr = true;
            for (const pr of result.data) {
              // Look for distinct PR branch name
              if (pr.head.ref === "${{ env.pr.source-branch }}") {
                console.log("PR with head ref " + pr.head.ref + " already exists");
                create_new_pr = false;
                break;
              }
            }
            // If no PR with distinguished branch name has been found
            // create a new PR to track changes to renv.lock.
            if (create_new_pr) {
              console.log("Creating a new PR");
              const result2 = await github.rest.pulls.create({
                title: 'Templates data updates from ${{ github.repository }}',
                owner: repo_owner,
                repo: repo_name,
                head: '${{ env.pr.source-branch }}',
                base: '${{ env.pr.target-branch }}',
                body: [
                  'This PR has been automatically generated by ',
                  'check-templates workflow from ${{ github.repository }}.',
                  '\n\nPlease review the changes.'
                ].join('')
              });
              // Assign reviewers to the PR
              const reviewer_list = `${{ fromJSON(env[format('{0}.reviewers', github.repository)]) }}`
              console.log(reviewer_list);
              const result3 = await github.rest.pulls.requestReviewers({
                owner: repo_owner,
                repo: repo_name,
                pull_number: result2.data.number,
                reviewers: reviewer_list
              });
            }
